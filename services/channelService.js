const { getBot } = require("./botService");
const db = require("./dbService");

// Function to get bot instance
const bot = () => getBot();

// Helper function for formatting posts in Amharic
function formatPostForChannel(post) {
  const typeLabel =
    post.property_type === "residential" ? "·ã®·àö·ä®·à´·ã≠ ·â§·âµ" : "·ã®·àö·ä®·à´·ã≠ ·àµ·à´ ·â¶·â≥";

  // Use display ID with PREPOSTS offset
  const preposts = parseInt(process.env.PREPOSTS) || 0;
  const displayId = post.id + preposts;

  let message = `<b>${typeLabel}</b>\n`;
  message += `<b>ID</b> ${String(displayId).padStart(5, "0")}\n\n`;

  if (post.title) {
    message += `<b>·ãì·ã≠·äê·âµ:</b> ${post.title}`;

    // Add additional property details
    if (post.villa_type) {
      message += ` - ${post.villa_type}`;
    }
    if (post.villa_type_other) {
      message += ` - ${post.villa_type_other}`;
    }
    if (post.rooms_count) {
      message += ` (${post.rooms_count} ·ä≠·çç·àç)`;
    }
    if (post.floor) {
      message += ` - ${post.floor}`;
    }
    message += `\n\n`;
  }

  // Property specifications
  let specs = [];
  if (post.bedrooms) {
    specs.push(`üõèÔ∏è ${post.bedrooms} ·àò·äù·â≥ ·ä≠·çç·àç`);
  }
  if (post.bathrooms) {
    specs.push(`üöø ${post.bathrooms} ·àò·â≥·å†·â¢·ã´ ·â§·âµ`);
  }
  if (post.bathroom_type) {
    specs.push(`üöø ${post.bathroom_type} ·àò·â≥·å†·â¢·ã´ ·â§·âµ`);
  }

  if (specs.length > 0) {
    message += `<b>·ãù·à≠·ãù·àÆ·âΩ:</b>\n${specs.join(" ")}`;

    // Property size on new line
    if (post.property_size) {
      message += `\nüìê ${post.property_size}`;
    }

    message += `\n\n`;
  } else if (post.property_size) {
    // If only property size exists
    message += `<b>·ãù·à≠·ãù·àÆ·âΩ:</b>\nüìê ${post.property_size}\n\n`;
  }

  if (post.location) {
    message += `<b>·ä†·ãµ·à´·àª:</b> ${post.location}\n`;
  }

  if (post.price) {
    message += `<b>·ãã·åã:</b> ${post.price}\n\n`;
  }

  if (post.description) {
    message += `<b>·ãù·à≠·ãù·à≠ ·àò·åç·àà·å´:</b>\n${post.description}\n\n`;
  }

  // Add platform link if available
  if (
    post.platform_link &&
    post.platform_name &&
    post.platform_link.trim() !== ""
  ) {
    message += `<b>·â∞·å®·àõ·à™:</b> ·â§·â±·äï ·â† <a href="${post.platform_link}"><b>${post.platform_name}</b></a>ü§è\n\n`;
  }

  // Hashtags section
  message += `<b>·â∞·àò·à£·à£·ã≠ ·â§·â∂·âΩ</b>\n`;

  // Price range hashtag
  const priceHashtag = generatePriceHashtag(post.price);
  if (priceHashtag) {
    message += `#${priceHashtag}\n`;
  }

  // Property type hashtag (remove spaces)
  if (post.title) {
    const titleHashtag = post.title.replace(/\s+/g, "");
    message += `#${titleHashtag}\n`;
  }

  // Main address hashtag (extract first part of location, remove spaces)
  if (post.location) {
    const mainLocation = post.location.split(",")[0].trim().replace(/\s+/g, "");
    message += `#${mainLocation}`;
  }

  return message;
}

// Helper function to generate price range hashtag
function generatePriceHashtag(priceStr) {
  if (!priceStr) return null;

  // Extract numbers from price string
  const numbers = priceStr.match(/\d+/g);
  if (!numbers || numbers.length === 0) return null;

  const price = parseInt(numbers.join(""));

  if (price < 10000) return "·ä®_10·à∫_·â†·â≥·âΩ";
  if (price < 20000) return "·ä®_20·à∫_·â†·â≥·âΩ";
  if (price < 30000) return "·ä®_30·à∫_·â†·â≥·âΩ";
  if (price < 40000) return "·ä®_40·à∫_·â†·â≥·âΩ";
  if (price < 50000) return "·ä®_50·à∫_·â†·â≥·âΩ";
  if (price < 100000) return "·ä®_100·à∫_·â†·â≥·âΩ";
  if (price < 200000) return "·ä®_200·à∫_·â†·â≥·âΩ";
  if (price < 500000) return "·ä®_500·à∫_·â†·â≥·âΩ";
  if (price < 1000000) return "·ä®_1_·àö·àä·ãÆ·äï_·â†·â≥·âΩ";
  if (price < 2000000) return "·ä®_2_·àö·àä·ãÆ·äï_·â†·â≥·âΩ";
  if (price < 5000000) return "·ä®_5_·àö·àä·ãÆ·äï_·â†·â≥·âΩ";
  if (price < 10000000) return "·ä®_10_·àö·àä·ãÆ·äï_·â†·â≥·âΩ";

  return "·ä®_10_·àö·àä·ãÆ·äï_·â†·àã·ã≠";
}

// Helper function to generate caption for photos
function generatePhotoCaption(post) {
  const preposts = parseInt(process.env.PREPOSTS) || 0;
  const displayId = post.id + preposts;
  return `<b>ID</b> ${String(displayId).padStart(5, "0")}`;
}

// Format post for preview (same as channel but without contact info)
function formatPostForPreview(post) {
  const typeLabel =
    post.property_type === "residential" ? "·ã®·àö·ä®·à´·ã≠ ·â§·âµ" : "·ã®·àö·ä®·à´·ã≠ ·àµ·à´ ·â¶·â≥";

  // Use display ID with PREPOSTS offset
  const preposts = parseInt(process.env.PREPOSTS) || 0;
  const displayId = post.id + preposts;

  let message = `<b>${typeLabel}</b>\n`;
  message += `<b>ID</b> ${String(displayId).padStart(5, "0")}\n\n`;

  // Property type and details
  if (post.title) {
    message += `<b>·ãì·ã≠·äê·âµ</b> - ${post.title}`;

    // Add villa type if exists
    if (post.villa_type) {
      message += ` - ${post.villa_type}`;
    }
    if (post.villa_type_other) {
      message += ` - ${post.villa_type_other}`;
    }

    // Add floor info
    if (post.floor) {
      message += ` - ${post.floor}`;
    }

    message += `\n\n`;
  }

  // Property specifications
  let specs = [];
  if (post.bedrooms) {
    specs.push(`üõè ${post.bedrooms} ·àò·äù·â≥ ·ä≠·çç·àç`);
  }
  if (post.bathrooms) {
    specs.push(`üöø ${post.bathrooms} ·àò·â≥·å†·â¢·ã´ ·â§·âµ`);
  } else if (post.bathroom_type) {
    specs.push(`üöø ${post.bathroom_type} ·àò·â≥·å†·â¢·ã´ ·â§·âµ`);
  }

  if (specs.length > 0) {
    message += `<b>·ãù·à≠·ãù·àÆ·âΩ:</b>\n${specs.join("  ")}`;

    // Property size on new line
    if (post.property_size) {
      message += `\nüìê ${post.property_size}`;
    }

    message += `\n\n`;
  } else if (post.property_size) {
    // If only property size exists
    message += `<b>·ãù·à≠·ãù·àÆ·âΩ:</b>\nüìê ${post.property_size}\n\n`;
  }

  // Address
  if (post.location) {
    message += `<b>·ä†·ãµ·à´·àª</b> - ${post.location}\n`;
  }

  // Price
  if (post.price) {
    message += `<b>·ãã·åã</b> - ${post.price}\n\n`;
  }

  // Additional description
  if (post.description) {
    message += `<b>·â∞·å®·àõ·à™:</b>\n${post.description}\n\n`;
  }

  // Platform link if exists
  if (
    post.platform_link &&
    post.platform_name &&
    post.platform_link.trim() !== ""
  ) {
    message += `<b>·â∞·å®·àõ·à™:</b> ·â§·â±·äï ·â† <a href="${post.platform_link}"><b>${post.platform_name}</b></a>ü§è\n\n`;
  }

  // Contact information
  const contactName = post.display_name || post.user_name || "·ã®·àõ·ã≠·â≥·ãà·âÖ";
  message += `${contactName}\n`;

  if (post.contact_info) {
    message += `${post.contact_info}\n\n`;
  } else if (post.phone) {
    message += `${post.phone}\n\n`;
  }

  // Hashtags section
  message += `<b>·â∞·àò·à£·à£·ã≠ ·â§·â∂·âΩ</b>\n`;

  // Price range hashtag
  const priceHashtag = generatePriceHashtag(post.price);
  if (priceHashtag) {
    message += `#${priceHashtag}\n`;
  }

  // Property type hashtag (remove spaces)
  if (post.title) {
    const titleHashtag = post.title.replace(/\s+/g, "");
    message += `#${titleHashtag}\n`;
  }

  // Main address hashtag (extract first part of location, remove spaces)
  if (post.location) {
    const mainLocation = post.location.split(",")[0].trim().replace(/\s+/g, "");
    message += `#${mainLocation}`;
  }

  return message;
}

module.exports = {
  formatPostForChannel,

  async markPostAsRentedOnChannel(postId) {
    try {
      const post = await db.getPost(postId);
      if (!post || !post.channel_message_id) {
        console.log(`No channel message ID found for post ${postId}`);
        return false;
      }

      // Get current formatted post
      const currentPost = formatPostForChannel(post);

      // Add "RENTED" status to the message with centered alignment
      const rentedPost = `<b>--- ·ã≠·àÖ ·â§·âµ ·â∞·ä®·à´·ã≠·â∑·àç ---</b>\n\n${currentPost}`;

      // Keep the original contact buttons
      const botUsername = process.env.BOT_USERNAME || "YourBotUsername";
      const deepLink = `https://t.me/${botUsername}?start=contact_${postId}`;
      const inlineKeyboard = {
        inline_keyboard: [
          [
            {
              text: "·ä†·ä®·à´·ã≠/·ã∞·àã·àã·ãç·äï ·ã´·åç·äô",
              url: deepLink,
            },
          ],
        ],
      };

      try {
        // Try to edit the message caption (for photo posts)
        await bot().editMessageCaption(rentedPost, {
          chat_id: process.env.CHANNEL_ID,
          message_id: post.channel_message_id,
          parse_mode: "HTML",
          reply_markup: inlineKeyboard,
        });

        console.log(`‚úÖ Post #${postId} marked as rented on channel`);
        return true;
      } catch (editError) {
        // If it's a text message or no caption to edit, use editMessageText instead
        if (
          editError.message.includes("message to edit not found") ||
          editError.message.includes("message is not modified") ||
          editError.message.includes("message can't be edited") ||
          editError.message.includes(
            "there is no caption in the message to edit"
          )
        ) {
          try {
            await bot().editMessageText(rentedPost, {
              chat_id: process.env.CHANNEL_ID,
              message_id: post.channel_message_id,
              parse_mode: "HTML",
              reply_markup: inlineKeyboard,
            });

            console.log(
              `‚úÖ Post #${postId} marked as rented on channel (text edit)`
            );
            return true;
          } catch (textEditError) {
            console.error(
              `Error editing channel message text for post ${postId}:`,
              textEditError
            );
            return false;
          }
        }

        console.error(
          `Error editing channel message for post ${postId}:`,
          editError
        );
        return false;
      }
    } catch (error) {
      console.error(
        `Error marking post ${postId} as rented on channel:`,
        error
      );
      return false;
    }
  },

  async publishToChannel(postId) {
    try {
      const post = await db.getPost(postId);
      if (!post) {
        throw new Error(`Post ${postId} not found`);
      }

      const formattedPost = formatPostForChannel(post);
      const photos = await db.getPostPhotos(postId);

      const contactButtonText = "·ä†·ä®·à´·ã≠/·ã∞·àã·àã·ãç·äï ·ã´·åç·äô";

      // Use deep linking to redirect users to private chat with bot
      const botUsername = process.env.BOT_USERNAME || "YourBotUsername"; // Make sure to set this in .env
      const deepLink = `https://t.me/${botUsername}?start=contact_${postId}`;

      const inlineKeyboard = {
        inline_keyboard: [
          [
            {
              text: contactButtonText,
              url: deepLink,
            },
          ],
        ],
      };

      let channelMessage = null;

      if (photos && photos.length > 0) {
        if (photos.length === 1) {
          // Single media: Send using appropriate method based on file type
          const media = photos[0];
          if (media.file_type === "video") {
            channelMessage = await bot().sendVideo(
              process.env.CHANNEL_ID,
              media.telegram_file_id,
              {
                caption: formattedPost,
                parse_mode: "HTML",
                reply_markup: inlineKeyboard,
              }
            );
          } else if (media.file_type === "document") {
            channelMessage = await bot().sendDocument(
              process.env.CHANNEL_ID,
              media.telegram_file_id,
              {
                caption: formattedPost,
                parse_mode: "HTML",
                reply_markup: inlineKeyboard,
              }
            );
          } else {
            channelMessage = await bot().sendPhoto(
              process.env.CHANNEL_ID,
              media.telegram_file_id,
              {
                caption: formattedPost,
                parse_mode: "HTML",
                reply_markup: inlineKeyboard,
              }
            );
          }

          console.log(`‚úÖ Post #${postId} published to channel with 1 media`);
        } else {
          // Multiple photos: Media group first, then first photo with full post + button

          // If there are additional photos, send them as media group first
          if (photos.length > 1) {
            const idCaption = generatePhotoCaption(post); // Returns "ID 00034" format
            const remainingPhotos = photos.slice(1); // Get photos from index 1 onwards

            const mediaGroup = remainingPhotos.map((photo, index) => ({
              type:
                photo.file_type === "video"
                  ? "video"
                  : photo.file_type === "document"
                  ? "document"
                  : "photo",
              media: photo.telegram_file_id,
              caption: index === 0 ? idCaption : undefined,
              parse_mode: index === 0 ? "HTML" : undefined,
            }));

            await bot().sendMediaGroup(process.env.CHANNEL_ID, mediaGroup);
          }

          // Then send first media with full post text and button
          const firstMedia = photos[0];
          if (firstMedia.file_type === "video") {
            channelMessage = await bot().sendVideo(
              process.env.CHANNEL_ID,
              firstMedia.telegram_file_id,
              {
                caption: formattedPost,
                parse_mode: "HTML",
                reply_markup: inlineKeyboard,
              }
            );
          } else if (firstMedia.file_type === "document") {
            channelMessage = await bot().sendDocument(
              process.env.CHANNEL_ID,
              firstMedia.telegram_file_id,
              {
                caption: formattedPost,
                parse_mode: "HTML",
                reply_markup: inlineKeyboard,
              }
            );
          } else {
            channelMessage = await bot().sendPhoto(
              process.env.CHANNEL_ID,
              firstMedia.telegram_file_id,
              {
                caption: formattedPost,
                parse_mode: "HTML",
                reply_markup: inlineKeyboard,
              }
            );
          }

          console.log(
            `‚úÖ Post #${postId} published to channel with ${photos.length} media`
          );
        }
      } else {
        // Send text-only post with inline button
        channelMessage = await bot().sendMessage(
          process.env.CHANNEL_ID,
          formattedPost,
          {
            parse_mode: "HTML",
            reply_markup: inlineKeyboard,
          }
        );

        console.log(`‚úÖ Post #${postId} published to channel (text only)`);
      }

      // Store channel message ID if we have one
      if (channelMessage && channelMessage.message_id) {
        await db.updatePostChannelMessageId(postId, channelMessage.message_id);
      }

      // Update post status to published
      await db.updatePostStatus(postId, "published");
    } catch (error) {
      console.error(`‚ùå Error publishing post ${postId}:`, error);
      throw error;
    }
  },

  async sendContactInfoPrivately(userId, post) {
    try {
      // Prepare contact information
      const contactName = post.display_name || post.user_name || "·ã®·àõ·ã≠·â≥·ãà·âÖ";
      let contactInfo = `<b>·ä†·ä®·à´·ã≠/·ã∞·àã·àã:</b>\n\n`;
      contactInfo += `<b>üë®üèΩ‚Äçüíº ${contactName}</b>\n`;

      if (post.contact_info) {
        contactInfo += `<b>üìû </b>${post.contact_info}\n\n`;
      } else if (post.phone) {
        contactInfo += `<b>üìû </b>${post.phone}\n\n`;
      }

      // Send contact info as private message
      await bot().sendMessage(userId, contactInfo, {
        parse_mode: "HTML",
        reply_markup: {
          inline_keyboard: [
            [
              {
                text: "·â†·âÄ·å•·â≥ ·ã´·äê·åã·åç·à©",
                url: `tg://user?id=${post.telegram_id}`,
              },
            ],
          ],
        },
      });
    } catch (error) {
      console.error("Error sending contact info privately:", error);

      // If private message fails, user may need to start the bot first
      try {
        await bot().sendMessage(
          userId,
          "‚ùå ·ã®·åç·àç ·àò·àç·ä•·ä≠·âµ ·àò·àã·ä≠ ·ä†·àç·â∞·âª·àà·àù·ç¢ ·ä•·â£·ä≠·ãé ·â†·àò·åÄ·àò·à™·ã´ /start ·ã≠·å´·äë·ç£ ·ä®·ãö·ã´ ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢"
        );
      } catch (fallbackError) {
        console.error("Could not send fallback message:", fallbackError);
      }
    }
  },

  // Helper function to format Ethiopian phone numbers to international format
  formatPhoneToInternational(phone) {
    if (!phone) return null;

    // Remove any spaces, dashes, or other formatting
    const cleanPhone = phone.replace(/[\s-+()]/g, "");

    // Check if it's already in international format
    if (cleanPhone.startsWith("251")) {
      return `+${cleanPhone}`;
    }

    // Convert Ethiopian local numbers to international
    if (cleanPhone.startsWith("09")) {
      return `+251${cleanPhone.substring(1)}`;
    } else if (cleanPhone.startsWith("07")) {
      return `+251${cleanPhone.substring(1)}`;
    } else if (cleanPhone.startsWith("01")) {
      return `+251${cleanPhone.substring(1)}`;
    }

    // If format doesn't match expected patterns, check if it's numeric before applying 251 format
    // If it's not numeric (like a name), return as-is without modification
    if (!/^\d+$/.test(cleanPhone)) {
      return phone; // Return original input if not numeric
    }

    // If numeric but doesn't match expected patterns, apply 251 format
    return `+251${cleanPhone}`;
  },

  async sendCombinedContactMessage(userId, post) {
    try {
      // Prepare contact information
      const contactName = post.display_name || post.user_name || "·ã®·àõ·ã≠·â≥·ãà·âÖ";

      // Removed welcome message - show broker info directly
      let combinedMessage = `<b>·ä†·ä®·à´·ã≠/·ã∞·àã·àã:</b>\n\n`;
      combinedMessage += `<b>${contactName}</b>\n`;

      // Format phone number to international and make it clickable
      const contactPhone = post.contact_info || post.phone;
      let internationalPhone = null;

      if (contactPhone) {
        internationalPhone = this.formatPhoneToInternational(contactPhone);
        if (internationalPhone) {
          // Make phone number clickable as a link
          combinedMessage += `<b>üìû </b><a href="tel:${internationalPhone}">${internationalPhone}</a>\n\n`;
        } else {
          combinedMessage += `<b>üìû </b>${contactPhone}\n\n`;
        }
      }

      combinedMessage += `<i>·àà·àò·âÄ·å†·àç ·ä®·â≥·âΩ ·ä®·âÄ·à®·â°·âµ ·ä†·äï·ã±·äï ·ã≠·àù·à®·å°</i>`;

      // Check if post creator is an admin
      const isPostCreatorAdmin =
        await require("../controllers/adminController").isAdmin(
          post.telegram_id
        );

      // Prepare inline keyboard (no call button - Telegram doesn't support tel: URLs in buttons)
      const inlineKeyboard = [];

      // Only add direct contact button if post creator is NOT an admin
      if (!isPostCreatorAdmin) {
        inlineKeyboard.push([
          {
            text: "·ä†·ä®·à´·ã≠/·ã∞·àã·àã·ãç·äï ·â†·â¥·àå·åç·à´·àù ·àà·àõ·äê·åã·åà·à≠",
            url: `tg://user?id=${post.telegram_id}`,
          },
        ]);
      }

      inlineKeyboard.push([
        {
          text: "üõñ  ·ãà·ã∞ ·âª·äì·àâ ·àò·àò·àà·àµ",
          url: `https://t.me/c/${process.env.CHANNEL_ID.replace("-100", "")}`,
        },
      ]);

      inlineKeyboard.push([
        {
          text: "‚ûï ·ã®·à´·à∂·äï ·â§·âµ ·àà·àõ·àµ·â≥·ãà·âÖ",
          callback_data: "start_my_listing",
        },
      ]);

      // Send combined message with all buttons
      await bot().sendMessage(userId, combinedMessage, {
        parse_mode: "HTML",
        reply_markup: {
          inline_keyboard: inlineKeyboard,
        },
      });

      console.log(
        `‚úÖ Combined contact message sent to user ${userId} for post ${post.id}`
      );
    } catch (error) {
      console.error("Error sending combined contact message:", error);

      // If private message fails, user may need to start the bot first
      try {
        await bot().sendMessage(
          userId,
          "‚ùå ·ã®·åç·àç ·àò·àç·ä•·ä≠·âµ ·àò·àã·ä≠ ·ä†·àç·â∞·âª·àà·àù·ç¢ ·ä•·â£·ä≠·ãé ·â†·àò·åÄ·àò·à™·ã´ /start ·ã≠·å´·äë·ç£ ·ä®·ãö·ã´ ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢"
        );
      } catch (fallbackError) {
        console.error("Could not send fallback message:", fallbackError);
      }
    }
  },

  formatPostForChannel,
  formatPostForPreview,
  notifyAdmins: async function (postId, message) {
    try {
      const admins = await db.getAdmins();
      const failedAdmins = [];

      for (const admin of admins) {
        try {
          await bot().sendMessage(admin.telegram_id, message, {
            parse_mode: "HTML",
          });
          console.log(`‚úÖ Admin ${admin.telegram_id} notified successfully`);
        } catch (error) {
          console.error(
            `Failed to notify admin ${admin.telegram_id}:`,
            error.message
          );

          // Check if it's a "chat not found" error
          if (
            error.response &&
            error.response.body &&
            (error.response.body.description?.includes("chat not found") ||
              error.response.body.description?.includes("user not found") ||
              error.response.body.description?.includes("bot was blocked"))
          ) {
            console.warn(
              `‚ö†Ô∏è Admin ${admin.telegram_id} chat not accessible - marking as invalid`
            );
            failedAdmins.push(admin.telegram_id);
          }
        }
      }

      // Handle failed admin notifications
      if (failedAdmins.length > 0) {
        await this.handleInvalidAdmins(failedAdmins);
      }
    } catch (error) {
      console.error("Error notifying admins:", error);
    }
  },

  async handleInvalidAdmins(invalidAdminIds) {
    try {
      console.log(
        `üßπ Handling ${
          invalidAdminIds.length
        } invalid admin(s): ${invalidAdminIds.join(", ")}`
      );

      // For now, we'll just add a flag to mark them as inactive instead of deleting
      // This preserves data while preventing future notification attempts
      for (const adminId of invalidAdminIds) {
        await db.markAdminAsInactive(adminId);
        console.log(`‚úÖ Admin ${adminId} marked as inactive`);
      }

      console.log(
        "üí° Tip: Use the setup-admin.js script to reactivate admins if needed"
      );
    } catch (error) {
      console.error("Error handling invalid admins:", error);
    }
  },
};
