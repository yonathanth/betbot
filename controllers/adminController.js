const { getBot, setState, getState } = require("../services/botService");
const db = require("../services/dbService");
const channelService = require("../services/channelService");
const tokenService = require("../services/tokenService");

// Function to get bot instance
const bot = () => getBot();

async function isAdmin(chatId) {
  try {
    // Check environment variable first
    const adminIds = process.env.ADMIN_IDS?.split(",") || [];
    if (adminIds.includes(String(chatId))) {
      return true;
    }

    // Check database
    return await db.isAdmin(chatId);
  } catch (error) {
    console.error("Error checking admin status:", error);
    return false;
  }
}

function formatPostForAdmin(post) {
  const typeLabel =
    post.property_type === "residential" ? "·ã®·àö·ä®·à´·ã≠ ·â§·âµ" : "·ã®·àö·ä®·à´·ã≠ ·àµ·à´ ·â¶·â≥";

  // Use display ID with PREPOSTS offset
  const preposts = parseInt(process.env.PREPOSTS) || 0;
  const displayId = post.id + preposts;

  let message = `<b>${typeLabel}</b> - ID: ${displayId}\n\n`;

  if (post.title) {
    message += `üè∑Ô∏è <b>·ãì·ã≠·äê·âµ:</b> ${post.title}`;

    // Add additional property details
    if (post.villa_type) {
      message += ` - ${post.villa_type}`;
    }
    if (post.villa_type_other) {
      message += ` - ${post.villa_type_other}`;
    }
    if (post.rooms_count) {
      message += ` (${post.rooms_count} ·ä≠·çç·àç)`;
    }
    if (post.floor) {
      message += ` - ${post.floor}`;
    }
    message += `\n\n`;
  }

  // Property specifications
  let specs = [];
  if (post.bedrooms) {
    specs.push(`üõèÔ∏è ${post.bedrooms} ·àò·äù·â≥ ·ä≠·çç·àç`);
  }
  if (post.bathrooms) {
    specs.push(`üöø ${post.bathrooms} ·àò·â≥·å†·â¢·ã´ ·â§·âµ`);
  }
  if (post.bathroom_type) {
    specs.push(`üöø ${post.bathroom_type} ·àò·â≥·å†·â¢·ã´ ·â§·âµ`);
  }
  if (post.property_size) {
    specs.push(`üìê ${post.property_size}`);
  }

  if (specs.length > 0) {
    message += `<b>·ãù·à≠·ãù·àÆ·âΩ:</b>\n${specs.join(" ‚Ä¢ ")}\n\n`;
  }

  if (post.location) {
    message += `<b>·ä†·ãµ·à´·àª:</b> ${post.location}\n`;
  }

  if (post.price) {
    message += `<b>·ãã·åã:</b> ${post.price}\n`;
  }

  if (post.contact_info) {
    message += `<b>·àµ·àç·ä≠:</b> ${post.contact_info}\n`;
  }

  if (post.description) {
    message += `\nüìù <b>·â∞·å®·àõ·à™ ·àò·åç·àà·å´:</b>\n${post.description}\n`;
  }

  message += `\nüë§ <b>·àµ·àù ·â†:</b> ${
    post.display_name || post.user_name || "·ã®·àõ·ã≠·â≥·ãà·âÖ"
  }`;
  message += `\nüì± <b>·àµ·àç·ä≠:</b> ${post.phone || "·ä†·àç·âÄ·à®·â†·àù"}`;
  message += `\nüÜî <b>·ã®·â∞·å†·âÉ·àö ·àò·àà·ã´:</b> ${post.telegram_id}`;
  message += `\n‚è∞ <b>·ã®·âÄ·à®·â†·â†·âµ ·âÄ·äï:</b> ${new Date(post.created_at).toLocaleString(
    "am-ET"
  )}`;

  return message;
}

// Token Generation Handlers
async function handleAdminGenerateToken(callback) {
  try {
    const chatId = callback.message.chat.id;

    if (!(await isAdmin(chatId))) {
      return bot().answerCallbackQuery(callback.id, {
        text: "Access denied!",
      });
    }

    // Answer callback query first to prevent timeout
    bot().answerCallbackQuery(callback.id);

    setState(chatId, { step: "admin_token_select_type" });

    await bot().sendMessage(
      chatId,
      "üîë <b>Token Generation</b>\n\n" +
        "Choose the type of token you want to generate:",
      {
        parse_mode: "HTML",
        reply_markup: {
          inline_keyboard: [
            [
              {
                text: "üìú License Token",
                callback_data: "admin_token_type_license",
              },
            ],
            [
              {
                text: "üîÑ Recovery Token",
                callback_data: "admin_token_type_recovery",
              },
            ],
          ],
        },
      }
    );
  } catch (error) {
    console.error("Error in handleAdminGenerateToken:", error);
    try {
      bot().answerCallbackQuery(callback.id, { text: "Error!" });
    } catch (answerError) {
      console.error("Error answering callback query:", answerError);
    }
  }
}

async function handleAdminTokenTypeSelection(callback) {
  try {
    const chatId = callback.message.chat.id;
    const tokenType = callback.data.split("_")[3]; // admin_token_type_license or admin_token_type_recovery

    if (!(await isAdmin(chatId))) {
      return bot().answerCallbackQuery(callback.id, {
        text: "Access denied!",
      });
    }

    // Answer callback query first to prevent timeout
    bot().answerCallbackQuery(callback.id);

    if (tokenType === "license") {
      setState(chatId, { step: "admin_token_license_mode", tokenType });

      await bot().sendMessage(
        chatId,
        "üìú <b>License Token</b>\n\n" + "Choose the license mode:",
        {
          parse_mode: "HTML",
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "‚ôæÔ∏è Permanent",
                  callback_data: "admin_token_mode_permanent",
                },
              ],
              [
                {
                  text: "‚è∞ Periodic",
                  callback_data: "admin_token_mode_periodic",
                },
              ],
            ],
          },
        }
      );
    } else if (tokenType === "recovery") {
      setState(chatId, { step: "admin_token_recovery_minutes", tokenType });

      await bot().sendMessage(
        chatId,
        "üîÑ <b>Recovery Token</b>\n\n" +
          "Enter the validity period in minutes (e.g., 15 for 15 minutes):",
        {
          parse_mode: "HTML",
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "‚è™ Back to Token Types",
                  callback_data: "admin_generate_token",
                },
              ],
            ],
          },
        }
      );
    }
  } catch (error) {
    console.error("Error in handleAdminTokenTypeSelection:", error);
    try {
      bot().answerCallbackQuery(callback.id, { text: "Error!" });
    } catch (answerError) {
      console.error("Error answering callback query:", answerError);
    }
  }
}

async function handleAdminTokenModeSelection(callback) {
  try {
    const chatId = callback.message.chat.id;
    const mode = callback.data.split("_")[3]; // admin_token_mode_permanent or admin_token_mode_periodic

    if (!(await isAdmin(chatId))) {
      return bot().answerCallbackQuery(callback.id, {
        text: "Access denied!",
      });
    }

    // Answer callback query first to prevent timeout
    bot().answerCallbackQuery(callback.id);

    setState(chatId, {
      step: mode === "permanent" ? "admin_token_device_id" : "admin_token_days",
      tokenType: "license",
      mode,
    });

    if (mode === "permanent") {
      await bot().sendMessage(
        chatId,
        "‚ôæÔ∏è <b>Permanent License Token</b>\n\n" +
          "Enter the Device Code (DID):",
        {
          parse_mode: "HTML",
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "‚è™ Back to Modes",
                  callback_data: "admin_token_type_license",
                },
              ],
            ],
          },
        }
      );
    } else {
      await bot().sendMessage(
        chatId,
        "‚è∞ <b>Periodic License Token</b>\n\n" +
          "Enter the validity period in days (e.g., 7 for 7 days):",
        {
          parse_mode: "HTML",
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "‚è™ Back to Modes",
                  callback_data: "admin_token_type_license",
                },
              ],
            ],
          },
        }
      );
    }
  } catch (error) {
    console.error("Error in handleAdminTokenModeSelection:", error);
    try {
      bot().answerCallbackQuery(callback.id, { text: "Error!" });
    } catch (answerError) {
      console.error("Error answering callback query:", answerError);
    }
  }
}

async function handleAdminTokenInput(msg) {
  try {
    const chatId = msg.chat.id;
    const state = getState(chatId);

    if (!state || !state.step.startsWith("admin_token_")) {
      return;
    }

    const currentStep = state.step;

    switch (currentStep) {
      case "admin_token_recovery_minutes":
        await processRecoveryMinutesInput(msg, state);
        break;
      case "admin_token_days":
        await processDaysInput(msg, state);
        break;
      case "admin_token_device_id":
        await processDeviceIdInput(msg, state);
        break;
      case "admin_token_note":
        await processNoteInput(msg, state);
        break;
    }
  } catch (error) {
    console.error("Error in handleAdminTokenInput:", error);
    bot().sendMessage(msg.chat.id, "‚ùå Error processing token input.");
  }
}

async function processRecoveryMinutesInput(msg, state) {
  const minutes = parseInt(msg.text.trim());

  if (isNaN(minutes) || minutes < 1) {
    return bot().sendMessage(
      msg.chat.id,
      "‚ùå Please enter a valid number of minutes (minimum 1):"
    );
  }

  setState(msg.chat.id, {
    ...state,
    step: "admin_token_device_id",
    minutes,
  });

  await bot().sendMessage(
    msg.chat.id,
    "üîÑ <b>Recovery Token</b>\n\n" +
      `‚úÖ Duration: ${minutes} minutes\n\n` +
      "Enter the Device Code (DID):",
    {
      parse_mode: "HTML",
      reply_markup: {
        inline_keyboard: [
          [
            {
              text: "‚è™ Back to Minutes",
              callback_data: "admin_token_type_recovery",
            },
          ],
        ],
      },
    }
  );
}

async function processDaysInput(msg, state) {
  const days = parseInt(msg.text.trim());

  if (isNaN(days) || days < 1) {
    return bot().sendMessage(
      msg.chat.id,
      "‚ùå Please enter a valid number of days (minimum 1):"
    );
  }

  setState(msg.chat.id, {
    ...state,
    step: "admin_token_device_id",
    days,
  });

  await bot().sendMessage(
    msg.chat.id,
    "‚è∞ <b>Periodic License Token</b>\n\n" +
      `‚úÖ Duration: ${days} days\n\n` +
      "Enter the Device Code (DID):",
    {
      parse_mode: "HTML",
      reply_markup: {
        inline_keyboard: [
          [
            {
              text: "‚è™ Back to Days",
              callback_data: "admin_token_mode_periodic",
            },
          ],
        ],
      },
    }
  );
}

async function processDeviceIdInput(msg, state) {
  const did = msg.text.trim();

  if (!did || did.length < 1) {
    return bot().sendMessage(
      msg.chat.id,
      "‚ùå Please enter a valid Device Code:"
    );
  }

  setState(msg.chat.id, {
    ...state,
    step: "admin_token_note",
    did,
  });

  await bot().sendMessage(
    msg.chat.id,
    "üìù <b>Note (Optional)</b>\n\n" +
      "Enter a note for this token (or send 'skip' to continue without note):",
    {
      parse_mode: "HTML",
      reply_markup: {
        inline_keyboard: [
          [
            {
              text: "‚è≠Ô∏è Skip Note",
              callback_data: "admin_token_skip_note",
            },
          ],
          [
            {
              text: "‚è™ Back to Device ID",
              callback_data:
                state.tokenType === "license"
                  ? state.mode === "permanent"
                    ? "admin_token_mode_permanent"
                    : "admin_token_mode_periodic"
                  : "admin_token_type_recovery",
            },
          ],
        ],
      },
    }
  );
}

async function processNoteInput(msg, state) {
  const noteText = msg.text.trim().toLowerCase();

  let note = null;
  if (noteText !== "skip" && noteText !== "") {
    note = msg.text.trim();
  }

  // Generate the token (private key will be read from environment)
  try {
    let token;
    if (state.tokenType === "license") {
      token = tokenService.generateLicenseToken(
        null, // Private key will be read from TOKEN_PRIVATE_KEY env var
        state.did,
        state.mode,
        state.days,
        note
      );
    } else {
      token = tokenService.generateRecoveryToken(
        null, // Private key will be read from TOKEN_PRIVATE_KEY env var
        state.did,
        state.minutes,
        note
      );
    }

    // Clear state
    setState(msg.chat.id, { step: null });

    // Send the generated token
    const tokenTypeDisplay =
      state.tokenType === "license"
        ? state.mode === "permanent"
          ? "Permanent License"
          : `Periodic License (${state.days} days)`
        : `Recovery (${state.minutes} minutes)`;

    await bot().sendMessage(
      msg.chat.id,
      `‚úÖ <b>Token Generated Successfully!</b>\n\n` +
        `üîë <b>Type:</b> ${tokenTypeDisplay}\n` +
        `üì± <b>Device:</b> ${state.did}\n` +
        `${note ? `üìù <b>Note:</b> ${note}\n` : ""}\n` +
        `üé´ <b>Token:</b>\n<code>${token}</code>\n\n` +
        `‚ö†Ô∏è <b>Important:</b> Save this token securely. It cannot be recovered once this message is closed.`,
      {
        parse_mode: "HTML",
        reply_markup: {
          inline_keyboard: [
            [
              {
                text: "üîÑ Generate Another Token",
                callback_data: "admin_generate_token",
              },
            ],
            [
              {
                text: "üè† Back to Admin Dashboard",
                callback_data: "admin_back_to_dashboard",
              },
            ],
          ],
        },
      }
    );
  } catch (error) {
    console.error("Error generating token:", error);
    await bot().sendMessage(
      msg.chat.id,
      "‚ùå Error generating token. Please check your inputs and try again."
    );

    // Reset to start of flow
    setState(msg.chat.id, { step: "admin_token_select_type" });
  }
}

async function handleAdminTokenSkipNote(callback) {
  try {
    const chatId = callback.message.chat.id;
    const state = getState(chatId);

    if (!(await isAdmin(chatId))) {
      return bot().answerCallbackQuery(callback.id, {
        text: "Access denied!",
      });
    }

    // Answer callback query first to prevent timeout
    bot().answerCallbackQuery(callback.id);

    // Process with no note
    await processNoteInput({ text: "skip", chat: { id: chatId } }, state);
  } catch (error) {
    console.error("Error in handleAdminTokenSkipNote:", error);
    try {
      bot().answerCallbackQuery(callback.id, { text: "Error!" });
    } catch (answerError) {
      console.error("Error answering callback query:", answerError);
    }
  }
}

async function handleAdminBackToDashboard(callback) {
  try {
    const chatId = callback.message.chat.id;

    if (!(await isAdmin(chatId))) {
      return bot().answerCallbackQuery(callback.id, {
        text: "Access denied!",
      });
    }

    // Answer callback query first to prevent timeout
    bot().answerCallbackQuery(callback.id);

    // Clear any token generation state
    setState(chatId, { step: null });

    // Get stats and show dashboard
    const stats = await db.getStats();

    await bot().sendMessage(
      chatId,
      `üìä <b>Admin Dashboard</b>\n\n` +
        `üë• Total Users: ${stats.totalUsers}\n` +
        `üìã Total Posts: ${stats.totalPosts}\n` +
        `‚è≥ Pending Posts: ${stats.pendingPosts}\n` +
        `‚úÖ Published Posts: ${stats.publishedPosts}`,
      {
        parse_mode: "HTML",
        reply_markup: {
          inline_keyboard: [
            [
              {
                text: "üìã Review Pending Posts",
                callback_data: "admin_pending",
              },
            ],
            [
              {
                text: "üìä Post Statistics",
                callback_data: "admin_stats",
              },
            ],
            [
              {
                text: "‚ûï Create Admin Post",
                callback_data: "admin_create_post",
              },
            ],
            [
              {
                text: "üîë Generate Token",
                callback_data: "admin_generate_token",
              },
            ],
          ],
        },
      }
    );
  } catch (error) {
    console.error("Error in handleAdminBackToDashboard:", error);
    try {
      bot().answerCallbackQuery(callback.id, { text: "Error!" });
    } catch (answerError) {
      console.error("Error answering callback query:", answerError);
    }
  }
}

module.exports = {
  formatPostForAdmin,
  isAdmin,

  // Token generation handlers
  handleAdminGenerateToken,
  handleAdminTokenTypeSelection,
  handleAdminTokenModeSelection,
  handleAdminTokenInput,
  handleAdminTokenSkipNote,
  handleAdminBackToDashboard,

  async handleAdminCommand(msg) {
    try {
      const chatId = msg.chat.id;

      if (!(await isAdmin(chatId))) {
        return bot().sendMessage(
          chatId,
          "‚ùå Access denied! You are not an admin."
        );
      }

      const stats = await db.getStats();

      await bot().sendMessage(
        chatId,
        `üìä <b>Admin Dashboard</b>\n\n` +
          `üë• Total Users: ${stats.totalUsers}\n` +
          `üìã Total Posts: ${stats.totalPosts}\n` +
          `‚è≥ Pending Posts: ${stats.pendingPosts}\n` +
          `‚úÖ Published Posts: ${stats.publishedPosts}`,
        {
          parse_mode: "HTML",
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "üìã Review Pending Posts",
                  callback_data: "admin_pending",
                },
              ],
              [
                {
                  text: "üìä Post Statistics",
                  callback_data: "admin_stats",
                },
              ],
              [
                {
                  text: "‚ûï Create Admin Post",
                  callback_data: "admin_create_post",
                },
              ],
              [
                {
                  text: "üîë Generate Token",
                  callback_data: "admin_generate_token",
                },
              ],
            ],
          },
        }
      );
    } catch (error) {
      console.error("Error in handleAdminCommand:", error);
      bot().sendMessage(msg.chat.id, "‚ùå Error loading admin dashboard.");
    }
  },

  async handleAdminStats(callback) {
    try {
      const chatId = callback.message.chat.id;

      if (!(await isAdmin(chatId))) {
        return bot().answerCallbackQuery(callback.id, {
          text: "Access denied!",
        });
      }

      // Answer callback query first to prevent timeout
      bot().answerCallbackQuery(callback.id);

      setState(chatId, { step: "admin_get_post_id" });

      await bot().sendMessage(
        chatId,
        "üìä <b>Post Statistics</b>\n\n" + "·ã®·àõ·àµ·â≥·ãà·âÇ·ã´ ·àò·â≥·ãà·âÇ·ã´ ·âÅ·å•·à≠ (Post ID) ·ã´·àµ·åà·â°:",
        { parse_mode: "HTML" }
      );
    } catch (error) {
      console.error("Error in handleAdminStats:", error);
      try {
        bot().answerCallbackQuery(callback.id, { text: "Error!" });
      } catch (answerError) {
        console.error("Error answering callback query:", answerError);
      }
    }
  },

  async handlePostStatsInput(msg) {
    try {
      const chatId = msg.chat.id;
      const state = getState(chatId);

      if (!state || state.step !== "admin_get_post_id") {
        return;
      }

      const displayPostId = parseInt(msg.text);
      if (!displayPostId || displayPostId < 1) {
        return bot().sendMessage(chatId, "‚ùå ·ä•·â£·ä≠·ãé ·âµ·ä≠·ä≠·àà·äõ Post ID ·ã´·àµ·åà·â°:");
      }

      // Convert display ID to database ID
      const preposts = parseInt(process.env.PREPOSTS) || 0;
      const databasePostId = displayPostId - preposts;

      if (databasePostId < 1) {
        return bot().sendMessage(
          chatId,
          "‚ùå ·âµ·ä≠·ä≠·àà·äõ Post ID ·ä†·ã≠·ã∞·àà·àù·ç¢ ·ä•·â£·ä≠·ãé ·âµ·ä≠·ä≠·àà·äõ ·âÅ·å•·à≠ ·ã´·àµ·åà·â°·ç¢"
        );
      }

      const stats = await db.getPostStats(databasePostId);
      if (!stats) {
        return bot().sendMessage(chatId, "‚ùå ·àõ·àµ·â≥·ãà·âÇ·ã´·ãç ·ä†·àç·â∞·åà·äò·àù!");
      }

      const post = stats.post;
      const statsMessage =
        `üìä<b>Post #${displayPostId} Statistics</b>\n\n` +
        `<b>Title:</b> ${post.title || "N/A"}\n` +
        `<b>Location:</b> ${post.location || "N/A"}\n` +
        `<b>Price:</b> ${post.price || "N/A"}\n` +
        `<b>Created:</b> ${new Date(post.created_at).toLocaleDateString(
          "am-ET"
        )}\n\n` +
        `üìà <b>Statistics:</b>\n` +
        `üí¨ Contact Clicks: ${stats.contactClicks}\n` +
        `üë• Unique Clickers: ${stats.uniqueClickers}`;

      const keyboard = [];

      // Add clickers list button only if there are clickers
      if (stats.uniqueClickers > 0) {
        keyboard.push([
          {
            text: "üë• View Who Clicked",
            callback_data: `admin_view_clickers_${databasePostId}`,
          },
        ]);
      }

      await bot().sendMessage(chatId, statsMessage, {
        parse_mode: "HTML",
        reply_markup:
          keyboard.length > 0 ? { inline_keyboard: keyboard } : undefined,
      });

      // Clear state
      setState(chatId, { step: null });
    } catch (error) {
      console.error("Error in handlePostStatsInput:", error);
      bot().sendMessage(msg.chat.id, "‚ùå Error retrieving statistics.");
    }
  },

  async handleViewClickers(callback) {
    try {
      const chatId = callback.message.chat.id;

      if (!(await isAdmin(chatId))) {
        return bot().answerCallbackQuery(callback.id, {
          text: "Access denied!",
        });
      }

      // Answer callback query first
      bot().answerCallbackQuery(callback.id);

      const postId = callback.data.split("_")[3]; // admin_view_clickers_123
      const clickers = await db.getPostClickers(postId);

      if (!clickers.length) {
        return bot().sendMessage(chatId, "‚ùå No clickers found for this post.");
      }

      let clickersMessage = `üë• <b>Post #${postId} Clickers (${clickers.length})</b>\n\n`;

      clickers.forEach((clicker, index) => {
        const userName = clicker.name || "Unknown";
        const userPhone = clicker.phone || "No phone";
        const clickCount = clicker.click_count;
        const lastClick = new Date(clicker.last_click).toLocaleDateString(
          "am-ET"
        );

        clickersMessage += `${index + 1}. <b>${userName}</b>\n`;
        clickersMessage += `   üì± ${userPhone}\n`;
        clickersMessage += `   üÜî ${clicker.user_telegram_id}\n`;
        clickersMessage += `   üëÜ ${clickCount} click${
          clickCount > 1 ? "s" : ""
        }\n`;
        clickersMessage += `   üìÖ Last: ${lastClick}\n\n`;
      });

      // Split message if too long (Telegram has 4096 char limit)
      if (clickersMessage.length > 4000) {
        const chunks = this.splitMessage(clickersMessage, 4000);
        for (const chunk of chunks) {
          await bot().sendMessage(chatId, chunk, { parse_mode: "HTML" });
        }
      } else {
        await bot().sendMessage(chatId, clickersMessage, {
          parse_mode: "HTML",
        });
      }
    } catch (error) {
      console.error("Error in handleViewClickers:", error);
      try {
        bot().answerCallbackQuery(callback.id, { text: "Error!" });
      } catch (answerError) {
        console.error("Error answering callback query:", answerError);
      }
      bot().sendMessage(chatId, "‚ùå Error retrieving clickers list.");
    }
  },

  splitMessage(message, maxLength) {
    const chunks = [];
    let currentChunk = "";
    const lines = message.split("\n");

    for (const line of lines) {
      if ((currentChunk + line + "\n").length > maxLength) {
        if (currentChunk) {
          chunks.push(currentChunk.trim());
          currentChunk = "";
        }
      }
      currentChunk += line + "\n";
    }

    if (currentChunk) {
      chunks.push(currentChunk.trim());
    }

    return chunks;
  },

  async showPendingPosts(callback) {
    try {
      const chatId = callback.message.chat.id;

      if (!(await isAdmin(chatId))) {
        return bot().answerCallbackQuery(callback.id, {
          text: "Access denied!",
        });
      }

      // Answer callback query first to prevent timeout
      bot().answerCallbackQuery(callback.id);

      const posts = await db.getPendingPosts();

      if (posts.length === 0) {
        return bot().editMessageText("üì≠ No pending posts at the moment.", {
          chat_id: chatId,
          message_id: callback.message.message_id,
        });
      }

      for (const post of posts) {
        const message = formatPostForAdmin(post);

        // Get photos for this post
        const photos = await db.getPostPhotos(post.id);

        if (photos && photos.length > 0) {
          // Send media as media group with the post details as caption on first item
          const mediaGroup = photos.map((photo, index) => ({
            type:
              photo.file_type === "video"
                ? "video"
                : photo.file_type === "document"
                ? "document"
                : "photo",
            media: photo.telegram_file_id,
            caption: index === 0 ? message : undefined,
            parse_mode: index === 0 ? "HTML" : undefined,
          }));

          await bot().sendMediaGroup(chatId, mediaGroup);

          // Send approval buttons as separate message
          const preposts = parseInt(process.env.PREPOSTS) || 0;
          const displayId = post.id + preposts;

          await bot().sendMessage(
            chatId,
            `üìã Post ID: ${displayId} - Actions:`,
            {
              reply_markup: {
                inline_keyboard: [
                  [
                    { text: "‚úÖ Approve", callback_data: `approve_${post.id}` },
                    { text: "‚úèÔ∏è Edit", callback_data: `edit_${post.id}` },
                  ],
                  [{ text: "‚ùå Reject", callback_data: `reject_${post.id}` }],
                ],
              },
            }
          );
        } else {
          // Send text-only message with inline buttons
          await bot().sendMessage(chatId, message, {
            parse_mode: "HTML",
            reply_markup: {
              inline_keyboard: [
                [
                  { text: "‚úÖ Approve", callback_data: `approve_${post.id}` },
                  { text: "‚úèÔ∏è Edit", callback_data: `edit_${post.id}` },
                ],
                [{ text: "‚ùå Reject", callback_data: `reject_${post.id}` }],
              ],
            },
          });
        }
      }
    } catch (error) {
      console.error("Error in showPendingPosts:", error);
      try {
        bot().answerCallbackQuery(callback.id, {
          text: "Error loading posts!",
        });
      } catch (answerError) {
        console.error("Error answering callback query:", answerError);
      }
    }
  },

  async handlePostApproval(callback) {
    try {
      const chatId = callback.message.chat.id;
      const action = callback.data.split("_")[0];
      const postId = callback.data.split("_")[1];

      if (!(await isAdmin(chatId))) {
        return bot().answerCallbackQuery(callback.id, {
          text: "Access denied!",
        });
      }

      if (action === "approve") {
        await db.updatePostStatus(postId, "approved");
        await channelService.publishToChannel(postId);

        // Notify user with option to add new ad
        const post = await db.getPost(postId);
        await bot().sendMessage(
          post.telegram_id,
          "üéâ ·àõ·àµ·â≥·ãà·âÇ·ã´·ãé ·å∏·ãµ·âÜ ·âª·äì·àã·âΩ·äï ·àã·ã≠ ·â∞·àà·âã·àç! ·â∞·å®·àõ·à™ ·àõ·àµ·â≥·ãà·âÇ·ã´·ãé·âΩ·äï ·ã≠·àç·âÄ·âÅ·ç¢"
        );

        await bot().editMessageText(
          callback.message.text + "\n\n‚úÖ <b>APPROVED & PUBLISHED</b>",
          {
            chat_id: chatId,
            message_id: callback.message.message_id,
            parse_mode: "HTML",
          }
        );

        bot().answerCallbackQuery(callback.id, {
          text: "Post approved and published!",
        });
      } else if (action === "reject") {
        // Ask for rejection reason
        setState(chatId, {
          step: "admin_rejection_reason",
          postId: parseInt(postId),
          rejectionMessageId: callback.message.message_id,
        });

        await bot().sendMessage(
          chatId,
          "‚ùå <b>·àù·ä≠·äï·ã´·âµ·ãé·äï  ·ã≠·åª·çâ</b>\n\n" +
            "·ä•·â£·ä≠·ãé ·àõ·àµ·â≥·ãà·âÇ·ã´·ãç ·àà·àù·äï ·ãç·ãµ·âÖ ·ä•·äï·ã∞·â∞·ã∞·à®·åà ·àù·ä≠·äï·ã´·â±·äï ·ã≠·åç·àà·åπ:",
          { parse_mode: "HTML" }
        );

        bot().answerCallbackQuery(callback.id, { text: "·àù·ä≠·äï·ã´·â±·äï ·ã≠·åª·çâ..." });
      }
    } catch (error) {
      console.error("Error in handlePostApproval:", error);
      try {
        bot().answerCallbackQuery(callback.id, {
          text: "Error processing request!",
        });
      } catch (answerError) {
        console.error("Error answering callback query:", answerError);
      }
    }
  },

  async handleEditPost(callback) {
    try {
      const chatId = callback.message.chat.id;

      const postId = callback.data.split("_")[1];

      if (!(await isAdmin(chatId))) {
        return bot().answerCallbackQuery(callback.id, {
          text: "Access denied!",
        });
      }

      // Answer callback query first to prevent timeout
      bot().answerCallbackQuery(callback.id);

      // Get post details to determine property type and available fields
      const post = await db.getPost(parseInt(postId));

      if (!post) {
        return bot().sendMessage(chatId, "‚ùå Post not found!");
      }

      setState(chatId, {
        step: "admin_edit",
        postId: parseInt(postId),
        post: post,
      });

      // Create property-type-aware edit options
      const editOptions = this.getEditOptionsForPost(post, postId);

      await bot().sendMessage(
        chatId,
        `‚úèÔ∏è <b>Edit Post Mode</b>\n\n` +
          `üìã <b>Post:</b> ${post.title || "N/A"}\n` +
          `üõñ <b>Type:</b> ${
            post.property_type === "residential" ? "·ã®·àò·äñ·à™·ã´ ·â§·âµ" : "·ã®·äï·åç·ãµ ·â§·âµ"
          }\n\n` +
          `What would you like to edit?`,
        {
          parse_mode: "HTML",
          reply_markup: {
            inline_keyboard: editOptions,
          },
        }
      );
    } catch (error) {
      console.error("Error in handleEditPost:", error);
      try {
        bot().answerCallbackQuery(callback.id, { text: "Error!" });
      } catch (answerError) {
        console.error("Error answering callback query:", answerError);
      }
    }
  },

  // Helper function to get edit options based on post type
  getEditOptionsForPost(post, postId) {
    const commonFields = [
      [{ text: "üìã Title", callback_data: `edit_field_title_${postId}` }],
      [{ text: "üìç Location", callback_data: `edit_field_location_${postId}` }],
      [{ text: "üí∞ Price", callback_data: `edit_field_price_${postId}` }],
      [
        {
          text: "üìû Contact Info",
          callback_data: `edit_field_contact_info_${postId}`,
        },
      ],
      [
        {
          text: "üë§ Display Name",
          callback_data: `edit_field_display_name_${postId}`,
        },
      ],
    ];

    const propertySpecificFields = [];

    // Add property-specific fields based on property type and title
    if (post.property_type === "residential") {
      if (post.title === "·åç·â¢ ·ãç·àµ·å• ·ã´·àà" && post.rooms_count) {
        propertySpecificFields.push([
          {
            text: "üõñ Rooms Count",
            callback_data: `edit_field_rooms_count_${postId}`,
          },
        ]);
      }

      if (post.title === "·àô·àâ ·åç·â¢") {
        if (post.villa_type) {
          propertySpecificFields.push([
            {
              text: "üè° Villa Type",
              callback_data: `edit_field_villa_type_${postId}`,
            },
          ]);
        }
        if (post.villa_type_other) {
          propertySpecificFields.push([
            {
              text: "üè° Villa Type (Other)",
              callback_data: `edit_field_villa_type_other_${postId}`,
            },
          ]);
        }
      }

      if (["·äÆ·äï·ã∂·àö·äï·ã®·àù", "·ä†·çì·à≠·â≥·àõ"].includes(post.title) && post.floor) {
        propertySpecificFields.push([
          { text: "üè¢ Floor", callback_data: `edit_field_floor_${postId}` },
        ]);
      }

      if (post.bedrooms) {
        propertySpecificFields.push([
          {
            text: "üõèÔ∏è Bedrooms",
            callback_data: `edit_field_bedrooms_${postId}`,
          },
        ]);
      }

      if (post.bathrooms) {
        propertySpecificFields.push([
          {
            text: "üöø Bathrooms",
            callback_data: `edit_field_bathrooms_${postId}`,
          },
        ]);
      }

      if (post.bathroom_type) {
        propertySpecificFields.push([
          {
            text: "üöø Bathroom Type",
            callback_data: `edit_field_bathroom_type_${postId}`,
          },
        ]);
      }
    } else if (post.property_type === "commercial") {
      if (
        ["·â¢·àÆ", "·à±·âÖ", "·àò·åã·ãò·äï", "·àà·ã®·âµ·äõ·ãç·àù ·äï·åç·ãµ"].includes(post.title) &&
        post.floor
      ) {
        propertySpecificFields.push([
          { text: "üè¢ Floor", callback_data: `edit_field_floor_${postId}` },
        ]);
      }
    }

    // Add common fields that might be present
    if (post.property_size) {
      propertySpecificFields.push([
        {
          text: "üìê Property Size",
          callback_data: `edit_field_property_size_${postId}`,
        },
      ]);
    }

    if (post.description) {
      propertySpecificFields.push([
        {
          text: "üìù Description",
          callback_data: `edit_field_description_${postId}`,
        },
      ]);
    }

    if (post.platform_link) {
      propertySpecificFields.push([
        {
          text: "üîó Platform Link",
          callback_data: `edit_field_platform_link_${postId}`,
        },
      ]);
    }

    // Add photos editing option
    propertySpecificFields.push([
      {
        text: "üì∑ Media",
        callback_data: `edit_field_photos_${postId}`,
      },
    ]);

    // Combine all fields
    const allFields = [
      ...commonFields,
      ...propertySpecificFields,
      [{ text: "‚úÖ Done Editing", callback_data: `edit_done_${postId}` }],
    ];

    return allFields;
  },

  async handleEditField(callback) {
    try {
      const chatId = callback.message.chat.id;
      const parts = callback.data.split("_");

      // Handle compound field names (like contact_info, display_name, etc.)
      let field, postId;
      if (parts.length === 4) {
        field = parts[2];
        postId = parts[3];
      } else if (parts.length === 5) {
        field = `${parts[2]}_${parts[3]}`;
        postId = parts[4];
      } else {
        console.error("Invalid callback data format:", callback.data);
        return bot().answerCallbackQuery(callback.id, {
          text: "Invalid format!",
        });
      }

      if (!(await isAdmin(chatId))) {
        return bot().answerCallbackQuery(callback.id, {
          text: "Access denied!",
        });
      }

      // Answer callback query first to prevent timeout
      bot().answerCallbackQuery(callback.id);

      // Get post details for context
      const post = await db.getPost(postId);
      if (!post) {
        return bot().sendMessage(chatId, "‚ùå Post not found!");
      }

      setState(chatId, {
        step: `admin_edit_${field}`,
        postId: parseInt(postId),
        editingField: field,
        post: post,
      });

      // Get field-specific prompts and validation
      const fieldInfo = this.getFieldEditInfo(field, post);

      await bot().sendMessage(
        chatId,
        `‚úèÔ∏è <b>Edit ${fieldInfo.displayName}</b>\n\n` +
          `üìã <b>Current:</b> ${fieldInfo.currentValue}\n\n` +
          `${fieldInfo.prompt}`,
        {
          parse_mode: "HTML",
          reply_markup: fieldInfo.keyboard || undefined,
        }
      );
    } catch (error) {
      console.error("Error in handleEditField:", error);
      try {
        bot().answerCallbackQuery(callback.id, {
          text: "Error starting field edit!",
        });
      } catch (answerError) {
        console.error("Error answering callback query:", answerError);
      }
    }
  },

  // Helper function to get bathroom type options based on property title
  getBathroomTypeOptions(propertyTitle) {
    if (propertyTitle === "·àµ·â±·ã≤·ãÆ" || propertyTitle === "·åç·â¢ ·ãç·àµ·å• ·ã´·àà") {
      return [
        [{ text: "üöø ·ã®·åç·àç", callback_data: "bathroom_edit_·ã®·åç·àç" }],
        [{ text: "üöø ·ã®·åã·à´", callback_data: "bathroom_edit_·ã®·åã·à´" }],
      ];
    } else {
      return [
        [
          {
            text: "üöø ·àô·àâ ·àò·â≥·å†·â¢·ã´ ·â§·âµ",
            callback_data: "bathroom_edit_·àô·àâ ·àò·â≥·å†·â¢·ã´ ·â§·âµ",
          },
        ],
        [{ text: "üöΩ ·â∂·ã≠·àà·âµ ·â•·âª", callback_data: "bathroom_edit_·â∂·ã≠·àà·âµ ·â•·âª" }],
        [{ text: "üöø ·àª·ãà·à≠ ·â•·âª", callback_data: "bathroom_edit_·àª·ãà·à≠ ·â•·âª" }],
      ];
    }
  },

  // Helper function to get field-specific edit information
  getFieldEditInfo(field, post) {
    const fieldMappings = {
      title: {
        displayName: "Title",
        currentValue: post.title || "N/A",
        prompt: "üìã Enter the new title:",
        dbField: "title",
      },
      location: {
        displayName: "Location",
        currentValue: post.location || "N/A",
        prompt: "üìç Enter the new location:",
        dbField: "location",
      },
      price: {
        displayName: "Price",
        currentValue: post.price || "N/A",
        prompt: "üí∞ Enter the new price:",
        dbField: "price",
      },
      contact_info: {
        displayName: "Contact Info",
        currentValue: post.contact_info || "N/A",
        prompt: "üìû Enter the new contact information:",
        dbField: "contact_info",
      },
      display_name: {
        displayName: "Display Name",
        currentValue: post.display_name || "N/A",
        prompt: "üë§ Enter the new display name:",
        dbField: "display_name",
      },
      description: {
        displayName: "Description",
        currentValue: post.description || "N/A",
        prompt: "üìù Enter the new description:",
        dbField: "description",
      },
      rooms_count: {
        displayName: "Rooms Count",
        currentValue: post.rooms_count || "N/A",
        prompt: "üõñ Enter the number of rooms (numbers only):",
        dbField: "rooms_count",
      },
      villa_type: {
        displayName: "Villa Type",
        currentValue: post.villa_type || "N/A",
        prompt: "üè° Select the villa type:",
        dbField: "villa_type",
        keyboard: {
          inline_keyboard: [
            [{ text: "üè° ·â™·àã", callback_data: "villa_edit_·â™·àã" }],
            [{ text: "üõñ ·åÇ+1", callback_data: "villa_edit_·åÇ+1" }],
            [{ text: "üè¢ ·åÇ+2", callback_data: "villa_edit_·åÇ+2" }],
            [{ text: "üè¢ ·åÇ+3", callback_data: "villa_edit_·åÇ+3" }],
            [{ text: "üèóÔ∏è ·àå·àã", callback_data: "villa_edit_·àå·àã" }],
          ],
        },
      },
      villa_type_other: {
        displayName: "Villa Type (Other)",
        currentValue: post.villa_type_other || "N/A",
        prompt: "üè° Enter the villa type:",
        dbField: "villa_type_other",
      },
      floor: {
        displayName: "Floor",
        currentValue: post.floor || "N/A",
        prompt: "üè¢ Enter the floor number (1, 2..) or 0 for ground floor:",
        dbField: "floor",
      },
      bedrooms: {
        displayName: "Bedrooms",
        currentValue: post.bedrooms || "N/A",
        prompt: "üõèÔ∏è Enter the number of bedrooms:",
        dbField: "bedrooms",
      },
      bathrooms: {
        displayName: "Bathrooms",
        currentValue: post.bathrooms || "N/A",
        prompt: "üöø Enter the number of bathrooms:",
        dbField: "bathrooms",
      },
      bathroom_type: {
        displayName: "Bathroom Type",
        currentValue: post.bathroom_type || "N/A",
        prompt: "üöø Select the bathroom type:",
        dbField: "bathroom_type",
        keyboard: {
          inline_keyboard: this.getBathroomTypeOptions(post.title),
        },
      },
      property_size: {
        displayName: "Property Size",
        currentValue: post.property_size || "N/A",
        prompt: "üìê Enter the property size:",
        dbField: "property_size",
      },
      platform_link: {
        displayName: "Platform Link",
        currentValue: post.platform_link || "N/A",
        prompt: "üîó Enter the platform link (URL):",
        dbField: "platform_link",
      },
      photos: {
        displayName: "Photos",
        currentValue: "Click to manage photos",
        prompt: "üì∑ Photo Management:\n\nChoose how you want to handle photos:",
        dbField: "photos",
        keyboard: {
          inline_keyboard: [
            [
              {
                text: "‚ûï Add photos to existing ones",
                callback_data: "admin_photo_add",
              },
            ],
            [
              {
                text: "üîÑ Replace all photos",
                callback_data: "admin_photo_replace",
              },
            ],
            [
              {
                text: "üóëÔ∏è Delete all photos",
                callback_data: "admin_photo_delete",
              },
            ],
          ],
        },
      },
    };

    return (
      fieldMappings[field] || {
        displayName: field,
        currentValue: "N/A",
        prompt: `Enter the new ${field}:`,
        dbField: field,
      }
    );
  },

  async handleEditInput(msg) {
    try {
      const chatId = msg.chat.id;
      const state = getState(chatId);

      if (!state || !state.step.startsWith("admin_edit_") || !state.postId) {
        return;
      }

      const field = state.editingField;
      const postId = state.postId;
      const post = state.post;

      // Handle photos differently - photos now use buttons, not text input
      if (field === "photos") {
        return bot().sendMessage(
          chatId,
          "‚ùå Please use the photo management buttons above to edit photos."
        );
      }

      // Get field info for validation
      const fieldInfo = this.getFieldEditInfo(field, post);

      // Validate input based on field type
      const validationResult = this.validateFieldInput(field, msg.text.trim());
      if (!validationResult.isValid) {
        return bot().sendMessage(chatId, `‚ùå ${validationResult.error}`);
      }

      // Update the post field
      const updateData = {};
      updateData[fieldInfo.dbField] = validationResult.value;

      await db.updatePostByAdmin(postId, updateData);

      // Get updated post for displaying new edit options
      const updatedPost = await db.getPost(postId);
      const editOptions = this.getEditOptionsForPost(updatedPost, postId);

      await bot().sendMessage(
        chatId,
        `‚úÖ ${fieldInfo.displayName} updated successfully!\n\n` +
          `üìã <b>New Value:</b> ${validationResult.value}\n\n` +
          "What else would you like to edit?",
        {
          parse_mode: "HTML",
          reply_markup: {
            inline_keyboard: editOptions,
          },
        }
      );

      setState(chatId, { step: "admin_edit", postId, post: updatedPost });
    } catch (error) {
      console.error("Error in handleEditInput:", error);
      bot().sendMessage(
        msg.chat.id,
        "‚ùå Failed to update field. Please try again."
      );
    }
  },

  // Helper function to validate field input
  validateFieldInput(field, value) {
    if (!value || value.length === 0) {
      return { isValid: false, error: "·ä•·â£·ä≠·ãé ·ãã·åã ·ã´·àµ·åà·â°:" };
    }

    switch (field) {
      case "rooms_count":
      case "bedrooms":
      case "bathrooms":
        if (
          !/^\d+$/.test(value) ||
          parseInt(value) < 1 ||
          parseInt(value) > 50
        ) {
          return { isValid: false, error: "·ä•·â£·ä≠·ãé ·âµ·ä≠·ä≠·àà·äõ ·âÅ·å•·à≠ ·ã´·àµ·åà·â° (1-50):" };
        }
        return { isValid: true, value: parseInt(value) };

      case "floor":
        if (
          value === "0" ||
          value.toLowerCase() === "·åç·à´·ãç·äï·ãµ" ||
          value.toLowerCase() === "ground"
        ) {
          return { isValid: true, value: "·åç·à´·ãç·äï·ãµ" };
        }
        if (
          !/^\d+$/.test(value) ||
          parseInt(value) < 1 ||
          parseInt(value) > 50
        ) {
          return {
            isValid: false,
            error: "·ä•·â£·ä≠·ãé ·âµ·ä≠·ä≠·àà·äõ ·çé·âÖ ·âÅ·å•·à≠ ·ã´·àµ·åà·â° ·ãà·ã≠·àù ·àà·åç·à´·ãç·äï·ãµ 0 ·ã≠·åª·çâ:",
          };
        }
        // Format floor number with "·äõ ·çé·âÖ" for commercial properties
        const floorNumber = parseInt(value);
        const formattedFloor = `${floorNumber}·äõ ·çé·âÖ`;
        return { isValid: true, value: formattedFloor };

      case "price":
        if (value.length < 1) {
          return { isValid: false, error: "·ä•·â£·ä≠·ãé ·ãã·åã·ãç·äï ·â†·ãù·à≠·ãù·à≠ ·ã´·àµ·åà·â°:" };
        }
        return { isValid: true, value: value };

      case "contact_info":
        if (value.length < 10) {
          return { isValid: false, error: "·ä•·â£·ä≠·ãé ·âµ·ä≠·ä≠·àà·äõ ·ã®·àµ·àç·ä≠ ·âÅ·å•·à≠ ·ã´·àµ·åà·â°:" };
        }
        return { isValid: true, value: value };

      case "title":
        if (value.length < 1) {
          return { isValid: false, error: "·ä•·â£·ä≠·ãé ·âµ·ä≠·ä≠·àà·äõ ·à≠·ãï·àµ ·ã´·àµ·åà·â°:" };
        }
        return { isValid: true, value: value };

      case "location":
        if (value.length < 1) {
          return { isValid: false, error: "·ä•·â£·ä≠·ãé ·âµ·ä≠·ä≠·àà·äõ ·ä†·ãµ·à´·àª ·ã´·àµ·åà·â°:" };
        }
        return { isValid: true, value: value };

      case "platform_link":
        // Basic URL validation
        try {
          new URL(value);
          return { isValid: true, value: value };
        } catch (e) {
          // Try with http:// prefix if no protocol is provided
          try {
            new URL(`http://${value}`);
            return { isValid: true, value: `http://${value}` };
          } catch (e2) {
            return {
              isValid: false,
              error: "·ä•·â£·ä≠·ãé ·âµ·ä≠·ä≠·àà·äõ ·àä·äï·ä≠ ·ã´·àµ·åà·â° (https://example.com):",
            };
          }
        }

      default:
        return { isValid: true, value: value };
    }
  },

  async handleAdminPhotoAdd(callback) {
    try {
      const chatId = callback.message.chat.id;
      const state = getState(chatId);

      if (!state || !state.postId) {
        return bot().answerCallbackQuery(callback.id, {
          text: "‚ùå No post selected for editing!",
        });
      }

      // Answer callback query first to prevent timeout
      bot().answerCallbackQuery(callback.id);

      const postId = state.postId;

      // Set state for adding photos
      setState(chatId, {
        step: "admin_photo_upload",
        postId: postId,
        photoMode: "add",
        photos: [],
      });

      // Get current photo count
      const currentPhotos = await db.getPostPhotos(postId);

      await bot().sendMessage(
        chatId,
        `üì∑ <b>Add Photos Mode</b>\n\n` +
          `Current photos: ${currentPhotos.length}/8\n` +
          `Available slots: ${8 - currentPhotos.length}\n\n` +
          `Send photos to add them to the existing ones.`,
        {
          parse_mode: "HTML",
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "‚úÖ Done Adding Photos",
                  callback_data: "admin_photos_done",
                },
              ],
            ],
          },
        }
      );
    } catch (error) {
      console.error("Error in handleAdminPhotoAdd:", error);
      try {
        bot().answerCallbackQuery(callback.id, { text: "Error!" });
      } catch (answerError) {
        console.error("Error answering callback query:", answerError);
      }
    }
  },

  async handleAdminPhotoReplace(callback) {
    try {
      const chatId = callback.message.chat.id;
      const state = getState(chatId);

      if (!state || !state.postId) {
        return bot().answerCallbackQuery(callback.id, {
          text: "‚ùå No post selected for editing!",
        });
      }

      // Answer callback query first to prevent timeout
      bot().answerCallbackQuery(callback.id);

      const postId = state.postId;

      // Delete all existing photos first
      await db.deletePostPhotos(postId);

      // Set state for replacing photos
      setState(chatId, {
        step: "admin_photo_upload",
        postId: postId,
        photoMode: "replace",
        photos: [],
      });

      await bot().sendMessage(
        chatId,
        `üîÑ <b>Replace Photos Mode</b>\n\n` +
          `All existing photos have been deleted.\n` +
          `Now send new photos (up to 8 photos).`,
        {
          parse_mode: "HTML",
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "‚úÖ Done Adding Photos",
                  callback_data: "admin_photos_done",
                },
              ],
            ],
          },
        }
      );
    } catch (error) {
      console.error("Error in handleAdminPhotoReplace:", error);
      try {
        bot().answerCallbackQuery(callback.id, { text: "Error!" });
      } catch (answerError) {
        console.error("Error answering callback query:", answerError);
      }
    }
  },

  async handleAdminPhotoDelete(callback) {
    try {
      const chatId = callback.message.chat.id;
      const state = getState(chatId);

      if (!state || !state.postId) {
        return bot().answerCallbackQuery(callback.id, {
          text: "‚ùå No post selected for editing!",
        });
      }

      // Answer callback query first to prevent timeout
      bot().answerCallbackQuery(callback.id);

      const postId = state.postId;

      // Delete all photos
      await db.deletePostPhotos(postId);

      // Go back to edit options
      const updatedPost = await db.getPost(postId);
      const editOptions = this.getEditOptionsForPost(updatedPost, postId);

      await bot().sendMessage(
        chatId,
        "‚úÖ All photos have been deleted!\n\nWhat else would you like to edit?",
        {
          reply_markup: {
            inline_keyboard: editOptions,
          },
        }
      );

      setState(chatId, { step: "admin_edit", postId, post: updatedPost });
    } catch (error) {
      console.error("Error in handleAdminPhotoDelete:", error);
      try {
        bot().answerCallbackQuery(callback.id, { text: "Error!" });
      } catch (answerError) {
        console.error("Error answering callback query:", answerError);
      }
    }
  },

  async handleAdminPhotosDone(callback) {
    try {
      const chatId = callback.message.chat.id;
      const state = getState(chatId);

      if (!state || !state.postId) {
        return bot().answerCallbackQuery(callback.id, {
          text: "‚ùå No post selected for editing!",
        });
      }

      // Answer callback query first to prevent timeout
      bot().answerCallbackQuery(callback.id);

      const postId = state.postId;
      const photos = state.photos || [];

      if (photos.length > 0) {
        // Save all photos
        for (const photo of photos) {
          await db.saveAdminPostPhoto(postId, photo);
        }

        await bot().sendMessage(
          chatId,
          `‚úÖ ${photos.length} photos have been saved successfully!`
        );
      }

      // Go back to edit options
      const updatedPost = await db.getPost(postId);
      const editOptions = this.getEditOptionsForPost(updatedPost, postId);

      await bot().sendMessage(
        chatId,
        "‚úÖ Photo editing completed!\n\nWhat else would you like to edit?",
        {
          reply_markup: {
            inline_keyboard: editOptions,
          },
        }
      );

      setState(chatId, { step: "admin_edit", postId, post: updatedPost });
    } catch (error) {
      console.error("Error in handleAdminPhotosDone:", error);
      try {
        bot().answerCallbackQuery(callback.id, { text: "Error!" });
      } catch (answerError) {
        console.error("Error answering callback query:", answerError);
      }
    }
  },

  async handleAdminPhotoUpload(msg) {
    try {
      const chatId = msg.chat.id;
      const state = getState(chatId);

      if (!state || state.step !== "admin_photo_upload" || !state.postId) {
        return;
      }

      let photos = state.photos || [];
      let newPhoto = null;

      // Handle regular photo
      if (msg.photo) {
        newPhoto = {
          file_id: msg.photo[msg.photo.length - 1].file_id,
          file_size: msg.photo[msg.photo.length - 1].file_size,
          type: "photo",
        };
      }
      // Handle document/image
      else if (
        msg.document &&
        msg.document.mime_type &&
        msg.document.mime_type.startsWith("image/")
      ) {
        newPhoto = {
          file_id: msg.document.file_id,
          file_size: msg.document.file_size,
          type: "document",
        };
      }
      // Handle video
      else if (msg.video) {
        // Check file size limit (50MB)
        if (msg.video.file_size > 50 * 1024 * 1024) {
          return bot().sendMessage(
            chatId,
            "‚ùå Video is over 50MB. Please send a smaller video."
          );
        }
        newPhoto = {
          file_id: msg.video.file_id,
          file_size: msg.video.file_size,
          type: "video",
        };
      }

      if (!newPhoto) {
        return bot().sendMessage(
          chatId,
          "‚ùå Please send a valid photo or video."
        );
      }

      // Get current saved photos count (for add mode)
      let currentSavedCount = 0;
      if (state.photoMode === "add") {
        const currentSavedPhotos = await db.getPostPhotos(state.postId);
        currentSavedCount = currentSavedPhotos.length;
      }

      const totalWillHave = currentSavedCount + photos.length + 1;

      // Check if adding this photo would exceed the limit
      if (totalWillHave > 8) {
        return bot().sendMessage(
          chatId,
          `‚ùå Cannot add more photos. This would make ${totalWillHave} photos total, but maximum is 8.\n\n` +
            `Current saved: ${currentSavedCount}\n` +
            `In queue: ${photos.length}\n` +
            `Please click 'Done' to save current photos or start over.`
        );
      }

      // Add the photo to the queue
      photos.push(newPhoto);
      setState(chatId, { ...state, photos });

      // Send confirmation
      await bot().sendMessage(
        chatId,
        `‚úÖ Photo ${photos.length} added to queue!\n\n` +
          `Total will be: ${currentSavedCount + photos.length}/8\n\n` +
          `${
            currentSavedCount + photos.length < 8
              ? "Send more photos or click 'Done' when finished."
              : "Maximum reached! Click 'Done' to save all photos."
          }`,
        {
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "‚úÖ Done Adding Photos",
                  callback_data: "admin_photos_done",
                },
              ],
            ],
          },
        }
      );
    } catch (error) {
      console.error("Error in handleAdminPhotoUpload:", error);
      bot().sendMessage(
        chatId,
        "‚ùå Error handling photo upload. Please try again."
      );
    }
  },

  async handleAdminMediaGroupPhoto(msg) {
    const chatId = msg.chat.id;
    try {
      const {
        addToMediaGroup,
        getMediaGroup,
        clearMediaGroup,
      } = require("../services/botService");
      const mediaGroupId = msg.media_group_id;

      // Add photo/video to media group collection
      let newPhoto = null;
      if (msg.photo) {
        newPhoto = {
          file_id: msg.photo[msg.photo.length - 1].file_id,
          file_size: msg.photo[msg.photo.length - 1].file_size,
          type: "photo",
        };
        addToMediaGroup(mediaGroupId, newPhoto);
      } else if (msg.video && msg.video.file_size <= 50 * 1024 * 1024) {
        newPhoto = {
          file_id: msg.video.file_id,
          file_size: msg.video.file_size,
          type: "video",
        };
        addToMediaGroup(mediaGroupId, newPhoto);
      }

      // Set a timeout to process the complete media group
      // This gives time for all photos in the group to arrive
      setTimeout(async () => {
        try {
          const state = getState(chatId);
          let photos = state.photos || [];

          // Check if this media group has already been processed
          const mediaGroupData =
            require("../services/botService").mediaGroups?.get(mediaGroupId);
          if (!mediaGroupData || mediaGroupData.processed) return;

          // Mark as processed to prevent duplicate confirmations
          mediaGroupData.processed = true;

          const mediaGroupPhotos = getMediaGroup(mediaGroupId);
          if (mediaGroupPhotos.length === 0) return;

          // Get current saved photos count (for add mode)
          let currentSavedCount = 0;
          if (state.photoMode === "add") {
            const currentSavedPhotos = await db.getPostPhotos(state.postId);
            currentSavedCount = currentSavedPhotos.length;
          }

          // Calculate how many photos we can add
          const maxCanAdd = 8 - currentSavedCount - photos.length;
          const totalPhotosToAdd = Math.min(mediaGroupPhotos.length, maxCanAdd);

          if (totalPhotosToAdd <= 0) {
            await bot().sendMessage(
              chatId,
              `‚ùå Cannot add more photos. Maximum is 8 total.\n\n` +
                `Current saved: ${currentSavedCount}\n` +
                `In queue: ${photos.length}\n` +
                `Please click 'Done' to save current photos.`
            );
            clearMediaGroup(mediaGroupId);
            return;
          }

          const newPhotos = mediaGroupPhotos.slice(0, totalPhotosToAdd);
          photos = [...photos, ...newPhotos];

          // Clear the media group from memory
          clearMediaGroup(mediaGroupId);

          // Update state
          setState(chatId, { ...state, photos });

          const totalWillHave = currentSavedCount + photos.length;

          // Send single confirmation message
          if (totalWillHave >= 8) {
            await bot().sendMessage(
              chatId,
              `‚úÖ ${newPhotos.length} photos added!${
                mediaGroupPhotos.length > totalPhotosToAdd
                  ? ` (Maximum reached, took first ${totalPhotosToAdd} of ${mediaGroupPhotos.length})`
                  : ""
              }\n\n` +
                `Total will be: 8/8\n\n` +
                `Maximum reached! Click 'Done' to save all photos.`,
              {
                reply_markup: {
                  inline_keyboard: [
                    [
                      {
                        text: "‚úÖ Done Adding Photos",
                        callback_data: "admin_photos_done",
                      },
                    ],
                  ],
                },
              }
            );
          } else {
            await bot().sendMessage(
              chatId,
              `‚úÖ ${newPhotos.length} photos added! Total will be: ${totalWillHave}/8\n\n` +
                `${
                  totalWillHave < 8
                    ? "Send more photos or click 'Done' when finished."
                    : "Maximum reached! Click 'Done' to save all photos."
                }`,
              {
                reply_markup: {
                  inline_keyboard: [
                    [
                      {
                        text: "‚úÖ Done Adding Photos",
                        callback_data: "admin_photos_done",
                      },
                    ],
                  ],
                },
              }
            );
          }
        } catch (error) {
          console.error("Error processing admin media group:", error);
        }
      }, 1000); // Wait 1 second for all photos in group to arrive
    } catch (error) {
      console.error("Error in handleAdminMediaGroupPhoto:", error);
      bot().sendMessage(
        chatId,
        "‚ùå Error handling photo group. Please try again."
      );
    }
  },

  async handleEditDone(callback) {
    try {
      const chatId = callback.message.chat.id;
      const postId = callback.data.split("_")[2];

      // Answer callback query first to prevent timeout
      bot().answerCallbackQuery(callback.id, { text: "Editing completed!" });

      setState(chatId, { step: null });

      await bot().editMessageText(
        "‚úÖ Editing completed!\n\nNow you can approve or reject the post:",
        {
          chat_id: chatId,
          message_id: callback.message.message_id,
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "‚úÖ Approve & Publish",
                  callback_data: `approve_${postId}`,
                },
                { text: "‚ùå Reject", callback_data: `reject_${postId}` },
              ],
            ],
          },
        }
      );
    } catch (error) {
      console.error("Error in handleEditDone:", error);
      try {
        bot().answerCallbackQuery(callback.id, {
          text: "Error completing edit!",
        });
      } catch (answerError) {
        console.error("Error answering callback query:", answerError);
      }
    }
  },

  async handleAdminSkipPlatformLink(callback) {
    try {
      const chatId = callback.message.chat.id;
      const state = getState(chatId);

      if (!(await isAdmin(chatId))) {
        return bot().answerCallbackQuery(callback.id, {
          text: "Access denied!",
        });
      }

      // Answer callback query first to prevent timeout
      bot().answerCallbackQuery(callback.id);

      setState(chatId, {
        step: null,
        admin_display_name: state.admin_display_name,
        admin_contact_info: state.admin_contact_info,
        admin_platform_link: null,
        admin_platform_name: null,
      });

      await bot().sendMessage(
        chatId,
        "‚úÖ ·àò·à®·åÉ·ãé·âΩ ·â∞·âÄ·àù·å†·ãã·àç!\n\n" + "·ä†·àÅ·äï ·àà·àõ·àµ·â≥·ãà·âÇ·ã´ ·çç·à∞·âµ ·ã≠·àò·à´·àâ..."
      );

      // Start the normal posting flow
      const postController = require("./postController");
      await postController.askPropertyType(chatId);
    } catch (error) {
      console.error("Error in handleAdminSkipPlatformLink:", error);
      try {
        bot().answerCallbackQuery(callback.id, { text: "Error!" });
      } catch (answerError) {
        console.error("Error answering callback query:", answerError);
      }
    }
  },

  async handleAdminCreatePost(callback) {
    try {
      const chatId = callback.message.chat.id;

      if (!(await isAdmin(chatId))) {
        return bot().answerCallbackQuery(callback.id, {
          text: "Access denied!",
        });
      }

      // Answer callback query first to prevent timeout
      bot().answerCallbackQuery(callback.id);

      setState(chatId, { step: "admin_post_name" });

      await bot().sendMessage(
        chatId,
        "‚ûï <b>Admin Post Creation</b>\n\n" +
          "·ä•·â£·ä≠·ãé ·â†·àõ·àµ·â≥·ãà·âÇ·ã´·ãç ·àã·ã≠ ·ä•·äï·ã≤·â≥·ã≠ ·ã®·àö·çà·àç·åâ·âµ·äï ·àµ·àù ·ã´·àµ·åà·â°:",
        { parse_mode: "HTML" }
      );
    } catch (error) {
      console.error("Error in handleAdminCreatePost:", error);
      try {
        bot().answerCallbackQuery(callback.id, { text: "Error!" });
      } catch (answerError) {
        console.error("Error answering callback query:", answerError);
      }
    }
  },

  async handleAdminPostInput(msg) {
    try {
      const chatId = msg.chat.id;
      const state = getState(chatId);

      if (
        !state ||
        (!state.step.startsWith("admin_post_") &&
          state.step !== "admin_photo_upload")
      ) {
        return;
      }

      // Handle admin photo uploads
      if (state.step === "admin_photo_upload") {
        return this.handleAdminPhotoUpload(msg);
      }

      if (state.step === "admin_post_name") {
        if (!msg.text || msg.text.length < 1) {
          return bot().sendMessage(chatId, "‚ùå ·ä•·â£·ä≠·ãé ·âµ·ä≠·ä≠·àà·äõ ·àµ·àù ·ã´·àµ·åà·â°:");
        }

        setState(chatId, {
          step: "admin_post_phone",
          admin_display_name: msg.text.trim(),
        });

        await bot().sendMessage(
          chatId,
          "üì± ·ä•·â£·ä≠·ãé ·â†·àõ·àµ·â≥·ãà·âÇ·ã´·ãç ·àã·ã≠ ·ä•·äï·ã≤·â≥·ã≠ ·ã®·àö·çà·àç·åâ·âµ·äï ·ã®·àµ·àç·ä≠ ·âÅ·å•·à≠ ·ã´·àµ·åà·â°:"
        );
      } else if (state.step === "admin_post_phone") {
        if (!msg.text || msg.text.length < 10) {
          return bot().sendMessage(chatId, "‚ùå ·ä•·â£·ä≠·ãé ·âµ·ä≠·ä≠·àà·äõ ·ã®·àµ·àç·ä≠ ·âÅ·å•·à≠ ·ã´·àµ·åà·â°:");
        }

        setState(chatId, {
          step: "admin_post_platform_link",
          admin_display_name: state.admin_display_name,
          admin_contact_info: msg.text.trim(),
        });

        await bot().sendMessage(
          chatId,
          "üîó ·â§·â±·äï ·â†·àå·àã ·â¶·â≥ ·ä†·àµ·â∞·ãã·ãç·âÄ·ãã·àç?\n\n" +
            "·â§·â± ·â† Facebook, TikTok, Jiji, YouTube ·ãà·ã≠·àù ·àå·àã ·â¶·â≥ ·ä®·â∞·àà·å†·çà ·àä·äï·ä©·äï ·ä•·ãö·àÖ ·ã´·àµ·åà·â°·ç¢\n\n" +
            "·ä´·àç·â∞·àà·å†·çà '·ãù·àà·àç' ·â•·àà·ãç ·ã≠·åª·çâ:",
          {
            reply_markup: {
              inline_keyboard: [
                [
                  {
                    text: "‚è≠Ô∏è ·àå·àã ·â¶·â≥ ·ä†·àà·å†·çç·ä©·àù",
                    callback_data: "admin_skip_platform_link",
                  },
                ],
              ],
            },
          }
        );
      } else if (state.step === "admin_post_platform_link") {
        let platformLink = null;
        let platformName = null;

        if (
          msg.text &&
          msg.text.trim() &&
          msg.text.trim().toLowerCase() !== "·ãù·àà·àç"
        ) {
          const link = msg.text.trim();

          // Validate URL
          let validatedLink = link;
          try {
            new URL(link);
          } catch (e) {
            // Try with http:// prefix if no protocol is provided
            try {
              new URL(`http://${link}`);
              validatedLink = `http://${link}`;
            } catch (e2) {
              return bot().sendMessage(
                chatId,
                "‚ùå ·ä•·â£·ä≠·ãé ·âµ·ä≠·ä≠·àà·äõ ·àä·äï·ä≠ ·ã´·àµ·åà·â° (https://example.com):\n\n·ãà·ã≠·àù ·àò·àµ·åà·â£·âµ ·ä´·àç·çà·àà·åâ '·ãù·àà·àç' ·â•·àà·ãç ·ã≠·åª·çâ"
              );
            }
          }

          // Detect platform
          platformName = "·àå·àã";
          if (
            validatedLink.includes("facebook.com") ||
            validatedLink.includes("fb.com")
          ) {
            platformName = "Facebook";
          } else if (validatedLink.includes("tiktok.com")) {
            platformName = "TikTok";
          } else if (validatedLink.includes("jiji.")) {
            platformName = "Jiji";
          } else if (
            validatedLink.includes("youtube.com") ||
            validatedLink.includes("youtu.be")
          ) {
            platformName = "YouTube";
          } else if (validatedLink.includes("instagram.com")) {
            platformName = "Instagram";
          } else if (
            validatedLink.includes("t.me") ||
            validatedLink.includes("telegram.me")
          ) {
            platformName = "Telegram";
          }

          platformLink = validatedLink;
          await bot().sendMessage(chatId, `‚úÖ ·ã® ${platformName} ·àä·äï·ä≠ ·â∞·âÄ·àù·åß·àç!`);
        }

        setState(chatId, {
          step: null,
          admin_display_name: state.admin_display_name,
          admin_contact_info: state.admin_contact_info,
          admin_platform_link: platformLink,
          admin_platform_name: platformName,
        });

        await bot().sendMessage(
          chatId,
          "‚úÖ ·àò·à®·åÉ·ãé·âΩ ·â∞·âÄ·àù·å†·ãã·àç!\n\n" + "·ä†·àÅ·äï ·àà·àõ·àµ·â≥·ãà·âÇ·ã´ ·çç·à∞·âµ ·ã≠·àò·à´·àâ..."
        );

        // Start the normal posting flow
        const postController = require("./postController");
        await postController.askPropertyType(chatId);
      }
    } catch (error) {
      console.error("Error in handleAdminPostInput:", error);
      bot().sendMessage(msg.chat.id, "‚ùå Error processing input.");
    }
  },

  async handleRejectionReasonInput(msg) {
    try {
      const chatId = msg.chat.id;
      const state = getState(chatId);

      if (!state || state.step !== "admin_rejection_reason") {
        return;
      }

      const reason = msg.text.trim();
      if (!reason || reason.length < 3) {
        return bot().sendMessage(
          chatId,
          "‚ùå·ä•·â£·ä≠·ãé ·åç·àã·åΩ ·àù·ä≠·äï·ã´·âµ ·ã´·àµ·åà·â° (·â¢·ã´·äï·àµ 10 ·çä·ã∞·àé·âΩ):"
        );
      }

      const postId = state.postId;
      const rejectionMessageId = state.rejectionMessageId;

      // Update post status with rejection reason
      await db.updatePostStatus(postId, "rejected", reason);

      // Get post details
      const post = await db.getPost(postId);

      // Notify user with rejection reason and try again option
      await bot().sendMessage(
        post.telegram_id,
        "‚ùå <b>·àõ·àµ·â≥·ãà·âÇ·ã´·ãé ·ä†·àç·â∞·àà·âÄ·âÄ·àù!</b>\n\n" +
          `üìù <b>·àù·ä≠·äï·ã´·âµ:</b> ${reason}\n\n` +
          "·ä•·â£·ä≠·ãé ·ä®·àã·ã≠ ·ã´·àà·ãç·äï ·âΩ·åç·à≠ ·ã´·àµ·â∞·ä´·ä≠·àâ ·ä•·äì ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©:",
        {
          parse_mode: "HTML",
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "üîÑ ·ä•·äï·ã∞·åà·äì ·àû·ä≠·à≠",
                  callback_data: "try_again_after_rejection",
                },
              ],
            ],
          },
        }
      );

      // Update the admin message
      await bot().editMessageText(
        `${post.title || "·àõ·àµ·â≥·ãà·âÇ·ã´"} - ID: ${
          post.id
        }\n\n‚ùå <b>REJECTED</b>\n\nüìù <b>·àù·ä≠·äï·ã´·âµ:</b> ${reason}`,
        {
          chat_id: chatId,
          message_id: rejectionMessageId,
          parse_mode: "HTML",
        }
      );

      // Send confirmation to admin
      await bot().sendMessage(
        chatId,
        "‚úÖ ·àõ·àµ·â≥·ãà·âÇ·ã´·ãç ·ä†·àç·â∞·àà·âÄ·âÄ·àù ·ä•·äì ·â∞·å†·âÉ·àö·ãç ·àù·ä≠·äï·ã´·â± ·â∞·äê·åç·àÆ·â≥·àç·ç¢"
      );

      // Clear state
      setState(chatId, { step: null });
    } catch (error) {
      console.error("Error in handleRejectionReasonInput:", error);
      bot().sendMessage(msg.chat.id, "‚ùå Error processing rejection reason.");
    }
  },

  async handleVillaTypeEdit(callback) {
    try {
      const chatId = callback.message.chat.id;
      const villaType = callback.data.split("_")[2];
      const state = getState(chatId);

      if (!state || state.step !== "admin_edit_villa_type") {
        return bot().answerCallbackQuery(callback.id, {
          text: "Invalid state!",
        });
      }

      // Answer callback query
      bot().answerCallbackQuery(callback.id);

      const postId = state.postId;
      const post = state.post;

      // Update villa type
      await db.updatePostByAdmin(postId, { villa_type: villaType });

      // Get updated post for displaying new edit options
      const updatedPost = await db.getPost(postId);
      const editOptions = this.getEditOptionsForPost(updatedPost, postId);

      await bot().editMessageText(
        `‚úÖ Villa Type updated successfully!\n\n` +
          `üìã <b>New Value:</b> ${villaType}\n\n` +
          "What else would you like to edit?",
        {
          chat_id: chatId,
          message_id: callback.message.message_id,
          parse_mode: "HTML",
          reply_markup: {
            inline_keyboard: editOptions,
          },
        }
      );

      setState(chatId, { step: "admin_edit", postId, post: updatedPost });
    } catch (error) {
      console.error("Error in handleVillaTypeEdit:", error);
      bot().answerCallbackQuery(callback.id, {
        text: "Error updating villa type!",
      });
    }
  },

  async handleBathroomTypeEdit(callback) {
    try {
      const chatId = callback.message.chat.id;
      const bathroomType = callback.data.split("_")[2];
      const state = getState(chatId);

      if (!state || state.step !== "admin_edit_bathroom_type") {
        return bot().answerCallbackQuery(callback.id, {
          text: "Invalid state!",
        });
      }

      // Answer callback query
      bot().answerCallbackQuery(callback.id);

      const postId = state.postId;
      const post = state.post;

      // Update bathroom type
      await db.updatePostByAdmin(postId, { bathroom_type: bathroomType });

      // Get updated post for displaying new edit options
      const updatedPost = await db.getPost(postId);
      const editOptions = this.getEditOptionsForPost(updatedPost, postId);

      await bot().editMessageText(
        `‚úÖ Bathroom Type updated successfully!\n\n` +
          `üìã <b>New Value:</b> ${bathroomType}\n\n` +
          "What else would you like to edit?",
        {
          chat_id: chatId,
          message_id: callback.message.message_id,
          parse_mode: "HTML",
          reply_markup: {
            inline_keyboard: editOptions,
          },
        }
      );

      setState(chatId, { step: "admin_edit", postId, post: updatedPost });
    } catch (error) {
      console.error("Error in handleBathroomTypeEdit:", error);
      bot().answerCallbackQuery(callback.id, {
        text: "Error updating bathroom type!",
      });
    }
  },
};
